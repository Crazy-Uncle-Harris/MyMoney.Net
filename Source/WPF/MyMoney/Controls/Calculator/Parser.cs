using System;
using System.Collections.Generic;
using System.Text;

namespace Walkabout.Controls
{

    /// <summary>
    /// This class parses a numeric expression and evaluates it. The grammar is:
    /// 
    /// expression ::= number 
    ///         | unaryop expression
    ///         | expression binaryop expression
    ///         | expression '%'
    ///         | '(' expression ')'
    ///         
    /// number ::= any valid decimal number (e.g. 1,251.72) with optional '$' sign and commas.
    ///     
    /// unaryop ::= '-'
    ///         | '+'
    /// 
    /// binaryop ::= '+'
    ///         | '-'
    ///         | '*'
    ///         | '/'
    /// 
    /// </summary>
    class Parser
    {
        double number;
        int openParens;
        int state;

        struct Operation
        {
            public Token Token;
            public double Number;
        }
        List<Operation> stack = new List<Operation>();

        enum Token
        {
            Number, Plus, Minus, Multiply, Divide, LeftParen, RightParen, Dollar, Percent, EOF,
            UnaryPlus, UnaryMinus // special tokens generated by parser.
        }

        /// <summary>
        /// Parse the expression.  See States.dgml in this project for description of this.
        /// </summary>
        /// <param name="expression"></param>
        public double Parse(string expression)
        {
            foreach (Token token in Tokenize(expression))
            {
                switch (state)
                {
                    case 0:
                        switch (token)
                        {
                            case Token.Number:
                                Shift(new Operation() { Token = Token.Number, Number = this.number });
                                state = 1;
                                break;
                            case Token.Plus:
                                Shift(new Operation() { Token = Token.UnaryPlus });
                                state = 2;
                                break;
                            case Token.Minus:
                                Shift(new Operation() { Token = Token.UnaryMinus });
                                state = 2;
                                break;
                            case Token.LeftParen:
                                Shift(new Operation() { Token = Token.LeftParen });
                                openParens++;
                                break;
                            case Token.Dollar:
                                state = 3;
                                break;
                            default:
                                UnexpectedToken(token, Token.Number, Token.Plus, Token.Minus, Token.LeftParen);
                                break;
                        }
                        break;
                    case 1:
                        switch (token)
                        {
                            case Token.Plus:
                                ReduceBinaryOperator(Token.Plus); // reduce binary operator based on precedence.
                                Shift(new Operation() { Token = Token.Plus });
                                state = 0;
                                break;
                            case Token.Minus:
                                ReduceBinaryOperator(Token.Minus); // reduce binary operator based on precedence.
                                Shift(new Operation() { Token = Token.Minus });
                                state = 0;
                                break;
                            case Token.Multiply:
                                ReduceBinaryOperator(Token.Multiply); // reduce binary operator based on precedence.
                                Shift(new Operation() { Token = Token.Multiply });
                                state = 0;
                                break;
                            case Token.Divide:
                                ReduceBinaryOperator(Token.Divide); // reduce binary operator based on precedence.
                                Shift(new Operation() { Token = Token.Divide });
                                state = 0;
                                break;
                            case Token.Percent:
                                ReducePercent();
                                state = 1;
                                break;
                            case Token.RightParen:
                                if (openParens > 0)
                                {
                                    CloseParens();
                                    state = 1;
                                    openParens--;
                                }
                                else
                                {
                                    goto default;
                                }
                                break;
                            case Token.EOF:
                                ReduceBinaryOperator(Token.EOF); // reduce binary operator based on precedence.  
                                if (openParens > 0)
                                {
                                    throw new Exception("Expecting close parentheses')'");
                                }
                                if (stack.Count > 1 || stack[0].Token != Token.Number)
                                {
                                    throw new Exception("Internal error, expecting stack to contain one number");
                                }
                                return stack[0].Number;
                            default:
                                UnexpectedToken(token, Token.Plus, Token.Minus, Token.Multiply, Token.Divide, Token.Percent, Token.RightParen);
                                break;
                        }
                        break;
                    case 2:
                        switch (token)
                        {
                            case Token.Number:
                                Shift(new Operation() { Token = Token.Number, Number = this.number });
                                ReduceUnaryOperator();
                                state = 1;
                                break;
                            case Token.LeftParen:
                                Shift(new Operation() { Token = Token.LeftParen, Number = this.number });
                                state = 0;
                                break;
                            case Token.Dollar:
                                state = 3;
                                break;
                            default:
                                UnexpectedToken(token, Token.Number, Token.LeftParen);
                                break;
                        }
                        break;
                    case 3:
                        switch (token)
                        {
                            case Token.Number:
                                Shift(new Operation() { Token = Token.Number, Number = this.number });
                                ReduceUnaryOperator();
                                state = 1;
                                break;
                            default:
                                UnexpectedToken(token, Token.Number);
                                break;
                        }
                        break;
                }
            }
            throw new Exception("Internal error, EOF should have returned from state 1 or thrown unexpected token errors in all other states");
        }

        static string TokenString(Token token)
        {
            switch (token)
            {
                case Token.Number:
                    return "Number";
                case Token.Plus:
                    return "Plus (+)";
                case Token.Minus:
                    return "Minus (-)";
                case Token.Multiply:
                    return "Multiply (*)";
                case Token.Divide:
                    return "Divide (/)";
                case Token.LeftParen:
                    return "Left Parenthesis (()";
                case Token.RightParen:
                    return "Right Parenthesis ())";
                case Token.Dollar:
                    return "Dollar ($)";
                case Token.Percent:
                    return "Percent (%)";
                case Token.UnaryPlus:
                    return "Plus (+)";
                case Token.UnaryMinus:
                    return "Minus (-)";
            }
            return null;
        }

        static void UnexpectedToken(Token found, params Token[] expected)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("Unexpected token " + TokenString(found) + ", expecting ");
            bool first = true;
            foreach (Token t in expected)
            {
                if (!first)
                {
                    sb.Append(", ");
                }
                sb.Append(TokenString(t));
                first = false;
            }
            throw new Exception(sb.ToString());
        }

        void Shift(Operation op)
        {
            stack.Add(op);
        }

        Operation Pop()
        {
            Operation op = new Operation();
            if (stack.Count > 0)
            {
                int i = stack.Count - 1;
                op = stack[i];
                stack.RemoveAt(i);
            }
            return op;
        }

        void ReduceUnaryOperator()
        {
            Operation number = Pop();
            Operation op = Pop();
            if (op.Token == Token.UnaryMinus)
            {
                number.Number = -number.Number;
            }
            Shift(number);
        }

        void ReduceBinaryOperator(Token token)
        {
            int len = stack.Count;
            while (len >= 3)
            {
                Operation right = stack[len - 1];
                Operation op = stack[len - 2];
                Operation left = stack[len - 3];
                if (left.Token == Token.Number && Precidence(token) <= Precidence(op.Token))
                {
                    Pop();
                    Pop();
                    Pop();
                    Shift(ComputeBinaryOperation(left, op, right));
                    len = stack.Count;
                }
                else
                {
                    break;
                }
            }
        }

        static int Precidence(Token token)
        {
            switch (token)
            {
                case Token.Plus:
                    return 1;
                case Token.Minus:
                    return 1;
                case Token.Multiply:
                    return 2;
                case Token.Divide:
                    return 2;
                case Token.LeftParen:
                    return 3;
                case Token.RightParen:
                    return 3;
                default:
                    return 0;
            }
        }

        static Operation ComputeBinaryOperation(Operation left, Operation op, Operation right)
        {
            switch (op.Token)
            {
                case Token.Plus:
                    left.Number += right.Number;
                    break;
                case Token.Minus:
                    left.Number -= right.Number;
                    break;
                case Token.Multiply:
                    left.Number *= right.Number;
                    break;
                case Token.Divide:
                    left.Number /= right.Number;
                    break;
                default:
                    throw new Exception("Expecting binary operator");
            }
            return left;
        }

        void CloseParens()
        {
            Operation right = Pop();
            Operation op = Pop();
            while (op.Token != Token.LeftParen)
            {
                Operation left = Pop();
                right = ComputeBinaryOperation(left, op, right);
                op = Pop();
            }
            Shift(right);
        }

        void ReducePercent()
        {
            Operation number = Pop();
            number.Number /= 100;
            Shift(number);
        }

        public double Number { get { return this.number; } }


        private IEnumerable<Token> Tokenize(string expression)
        {
            for (int i = 0, n = expression.Length; i < n; i++)
            {
                char c = expression[i];
                if (!Char.IsWhiteSpace(c))
                {
                    switch (c)
                    {
                        case '+':
                            yield return Token.Plus;
                            break;
                        case '-':
                            yield return Token.Minus;
                            break;
                        case '*':
                            yield return Token.Multiply;
                            break;
                        case '/':
                            yield return Token.Divide;
                            break;
                        case '$':
                            yield return Token.Dollar;
                            break;
                        case '%':
                            yield return Token.Percent;
                            break;
                        case '(':
                            yield return Token.LeftParen;
                            break;
                        case ')':
                            yield return Token.RightParen;
                            break;
                        default:
                            if (Char.IsDigit(c) || c == '.')
                            {
                                number = 0;
                                double decimalFactor = 0;

                                while (Char.IsDigit(c) || c == '.' || c == ',')
                                {
                                    if (c == ',')
                                    {
                                        // ignore thousand separators.
                                    }
                                    else if (c == '.')
                                    {
                                        if (decimalFactor > 0)
                                        {
                                            throw new ArgumentException(string.Format("Invalid second decimal point in expression '{0}'", expression));
                                        }
                                        decimalFactor = 10;
                                    }
                                    else
                                    {
                                        int v = Convert.ToInt16(c) - Convert.ToInt16('0');
                                        if (decimalFactor > 0)
                                        {
                                            number = number + (v / decimalFactor);
                                            decimalFactor *= 10;
                                        }
                                        else
                                        {
                                            number = (number * 10) + v;
                                        }
                                    }
                                    i++;
                                    c = i < n ? expression[i] : '\0';
                                }
                                i--;
                                yield return Token.Number;
                            }
                            else
                            {
                                throw new ArgumentException(string.Format("Unexpected char '{0}'", c));
                            }
                            break;
                    }
                }
            }
            while (true)
            {
                yield return Token.EOF;
            }
        }

    }

}
